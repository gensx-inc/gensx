import * as namedWorkflows from "./handler.js";
import Ajv from "npm:ajv@8.12.0";
import addFormats from "npm:ajv-formats@2.1.1";

// Initialize Ajv
const ajv = new Ajv({
  allErrors: true, // Return all errors, not just the first one
  strict: false, // Be more lenient with schema validation
});
addFormats(ajv); // Add support for formats like email, date, etc.

// Function to convert camelCase to train-case
function toTrainCase(str) {
  return str
    .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
    .replace(/([A-Z])([A-Z])(?=[a-z])/g, "$1-$2")
    .toLowerCase();
}

// Get all exports and normalize their names
const workflows = Object.fromEntries(
  Object.entries(namedWorkflows)
    .filter(
      ([key, value]) =>
        typeof value === "object" && value !== null && "run" in value,
    )
    .map(([key, workflow]) => [toTrainCase(workflow.name), workflow]),
);

// Cache for compiled validators
const validators = new Map();

// Function to validate input against JSON schema
function validateInput(input, schema, workflowName) {
  let validate = validators.get(workflowName);
  if (!validate) {
    validate = ajv.compile(schema);
    validators.set(workflowName, validate);
  }

  const valid = validate(input);
  if (!valid) {
    const errors = validate.errors.map((err) => {
      let message = err.message;
      if (err.instancePath) {
        message = `${err.instancePath} ${message}`;
      }
      return message;
    });
    throw new Error(`Validation failed:\n${errors.join("\n")}`);
  }
}

// Function to create a streaming response
function createStreamingResponse(stream) {
  const encoder = new TextEncoder();
  const readable = new ReadableStream({
    async start(controller) {
      try {
        for await (const chunk of stream) {
          if (chunk && typeof chunk === "object" && chunk.type === "stream") {
            controller.enqueue(encoder.encode(chunk.value));
          } else if (typeof chunk === "string") {
            controller.enqueue(encoder.encode(chunk));
          }
        }
        controller.close();
      } catch (error) {
        controller.error(error);
      }
    },
  });

  return new Response(readable, {
    headers: {
      "Content-Type": "text/plain; charset=utf-8",
      "Transfer-Encoding": "chunked",
      "X-Content-Type-Options": "nosniff",
      "Cache-Control": "no-cache",
    },
  });
}

const handler = async function (req) {
  const url = new URL(req.url);
  const workflowName = url.pathname.slice(1); // Remove leading slash

  // Get the workflow from exports
  const workflow = workflows[workflowName];
  if (!workflow) {
    return new Response(
      JSON.stringify({
        error: `Workflow "${workflowName}" not found. Available workflows: ${Object.keys(workflows).join(", ")}`,
      }),
      {
        status: 404,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  }

  try {
    const body = await req.json();

    // Get schema for this workflow
    const schema = await import("./schema.json", { with: { type: "json" } });
    const workflowSchema = schema.default.workflows[workflowName];

    if (!workflowSchema) {
      throw new Error(`Schema not found for workflow "${workflowName}"`);
    }

    // Validate input against schema
    validateInput(body, workflowSchema.input, workflowName);

    const result = await workflow.run(body);

    // Check if streaming was requested and the result is an async iterable
    if (typeof result === "object" && Symbol.asyncIterator in result) {
      return createStreamingResponse(result);
    }

    if (typeof result === "string") {
      return new Response(result, {
        headers: {
          "Content-Type": "text/plain; charset=utf-8",
        },
      });
    }

    // For non-streaming responses, return as JSON
    return new Response(JSON.stringify(result), {
      headers: {
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    const isValidationError =
      error instanceof Error &&
      (error.message.includes("Validation failed") ||
        error.message.includes("Schema"));

    return new Response(
      JSON.stringify({
        error:
          error instanceof Error ? error.message : "Unknown error occurred",
      }),
      {
        status: isValidationError ? 400 : 500,
        headers: {
          "Content-Type": "application/json",
        },
      },
    );
  }
};

// List available workflows at the root
const listWorkflows = () => {
  const availableWorkflows = Object.keys(workflows).map((name) => ({
    name,
    url: `/${name}`,
    schema: `/${name}/schema`,
  }));

  return new Response(
    JSON.stringify({
      workflows: availableWorkflows,
      message: "Send a POST request to a workflow URL with your input JSON",
    }),
    {
      headers: {
        "Content-Type": "application/json",
      },
    },
  );
};

Deno.serve(async (req) => {
  const url = new URL(req.url);

  // List workflows at root
  if (url.pathname === "/") {
    return listWorkflows();
  }

  // Get schema for a specific workflow
  if (url.pathname.endsWith("/schema")) {
    const workflowName = url.pathname.slice(1, -7); // Remove leading slash and "/schema"
    const schema = await import("./schema.json", { with: { type: "json" } });
    const workflowSchema = schema.default.workflows[workflowName];

    if (!workflowSchema) {
      return new Response(
        JSON.stringify({
          error: `Schema not found for workflow "${workflowName}"`,
        }),
        {
          status: 404,
          headers: {
            "Content-Type": "application/json",
          },
        },
      );
    }

    return new Response(JSON.stringify(workflowSchema), {
      headers: {
        "Content-Type": "application/json",
      },
    });
  }

  // Handle workflow requests
  if (req.method === "POST") {
    return handler(req);
  }

  return new Response(
    JSON.stringify({
      error:
        "Method not allowed. Use POST to invoke workflows, GET / to list available workflows, or GET /{workflowName}/schema for workflow schema",
    }),
    {
      status: 405,
      headers: {
        "Content-Type": "application/json",
      },
    },
  );
});
