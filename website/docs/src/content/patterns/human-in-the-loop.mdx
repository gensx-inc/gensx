---
title: Human-in-the-Loop
description: Pause workflows and wait for human input
---

# Human-in-the-Loop

Human-in-the-loop workflows let you pause workflow execution and wait for human input or approval before continuing. This is useful for approval workflows, manual review processes, or collecting user feedback.

## Basic usage

The `requestInput` function pauses your workflow and calls a trigger function with a callback URL. Your trigger function can integrate with any system to collect input:

```tsx
import { requestInput } from "@gensx/core";

const ApprovalWorkflow = gensx.Component(
  "ApprovalWorkflow",
  async ({ requestDetails }: { requestDetails: string }) => {
    const userInput = await requestInput<{ approved: boolean; comment?: string }>(
      async (callbackUrl) => {
        // Your custom trigger logic here
        console.log("Please provide input at:", callbackUrl);

        // Example: Send to your approval system
        await fetch("/api/approval-request", {
          method: "POST",
          body: JSON.stringify({ callbackUrl, requestDetails }),
        });
      }
    );

    if (userInput.approved) {
      return `Approved! ${userInput.comment || ""}`;
    } else {
      return "Request was rejected";
    }
  }
);
```

## Slack integration

You can integrate with Slack using interactive buttons:

```tsx
import { requestInput } from "@gensx/core";
import { WebClient } from "@slack/web-api";

const slack = new WebClient(process.env.SLACK_TOKEN);

const SlackApprovalWorkflow = gensx.Component(
  "SlackApprovalWorkflow",
  async ({ requestDetails }: { requestDetails: string }) => {
    const decision = await requestInput<{ approved: boolean; reason?: string }>(
      async (callbackUrl) => {
        await slack.chat.postMessage({
          channel: "#approvals",
          text: `New approval request: ${requestDetails}`,
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `*Approval Request*\n${requestDetails}`
              }
            },
            {
              type: "actions",
              elements: [
                {
                  type: "button",
                  text: { type: "plain_text", text: "Approve" },
                  style: "primary",
                  url: `${callbackUrl}?approved=true`
                },
                {
                  type: "button",
                  text: { type: "plain_text", text: "Reject" },
                  style: "danger",
                  url: `${callbackUrl}?approved=false`
                }
              ]
            }
          ]
        });
      }
    );

    return decision;
  }
);
```

## Web interface integration

For web applications, you can store pending approvals in a database:

```tsx
import { requestInput } from "@gensx/core";

const WebApprovalWorkflow = gensx.Component(
  "WebApprovalWorkflow",
  async ({ taskId }: { taskId: string }) => {
    const approval = await requestInput<{ approved: boolean; notes: string }>(
      async (callbackUrl) => {
        // Store in database for web interface to display
        await db.pendingApprovals.create({
          data: {
            taskId,
            callbackUrl,
            status: "pending",
            createdAt: new Date(),
          }
        });

        // Send notification
        await sendNotification({
          type: "approval_needed",
          taskId,
          message: `Task ${taskId} requires approval`
        });
      }
    );

    return approval;
  }
);
```

### Handling the callback

You'll need an API route to handle the callback:

```tsx
// app/api/approval/[taskId]/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function POST(
  request: NextRequest,
  { params }: { params: { taskId: string } }
) {
  const { approved, notes } = await request.json();

  // Get the stored callback URL
  const approval = await db.pendingApprovals.findUnique({
    where: { taskId: params.taskId }
  });

  if (!approval) {
    return NextResponse.json({ error: "Approval not found" }, { status: 404 });
  }

  // Call the GenSX callback URL
  const response = await fetch(approval.callbackUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ approved, notes })
  });

  if (response.ok) {
    await db.pendingApprovals.update({
      where: { taskId: params.taskId },
      data: { status: "completed" }
    });

    return NextResponse.json({ success: true });
  } else {
    return NextResponse.json({ error: "Failed to submit approval" }, { status: 500 });
  }
}
```

## Error handling

Handle errors gracefully in your trigger function:

```tsx
const RobustApprovalWorkflow = gensx.Component(
  "RobustApprovalWorkflow",
  async ({ request }: { request: string }) => {
    try {
      const result = await requestInput<{ approved: boolean }>(
        async (callbackUrl) => {
          // Handle errors in sending the approval request
          try {
            await sendApprovalRequest(callbackUrl, request);
          } catch (error) {
            console.error("Failed to send approval request:", error);
            // You might want to store this for retry logic
            throw error;
          }
        }
      );

      return result;
    } catch (error) {
      return { approved: false, error: "Failed to send approval request" };
    }
  }
);
```

## Type safety

Use Zod schemas for input validation:

```tsx
import { z } from "zod";

const ApprovalInputSchema = z.object({
  approved: z.boolean(),
  comment: z.string().optional(),
  approver: z.string(),
  timestamp: z.date()
});

type ApprovalInput = z.infer<typeof ApprovalInputSchema>;

const TypedApprovalWorkflow = gensx.Component(
  "TypedApprovalWorkflow",
  async () => {
    const input = await requestInput<ApprovalInput>(
      async (callbackUrl) => {
        await sendTypedApprovalRequest(callbackUrl);
      }
    );

    return `Approved by ${input.approver} at ${input.timestamp}`;
  }
);
```

## How it works

The `requestInput` function:

1. Generates a unique callback URL using the current node ID
2. Calls your trigger function with the callback URL
3. Pauses workflow execution and waits for the callback
4. Resumes when the callback URL receives data

The callback URL format is:
```
${process.env.GENSX_API_BASE_URL}/org/${process.env.GENSX_ORG}/workflowExecutions/${process.env.GENSX_EXECUTION_ID}/fulfill/${nodeId}
```
