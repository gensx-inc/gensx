---
title: Streaming
description: Build streaming applications with GenSX
---

# Streaming

GenSX provides utilities and hooks that make it easy to build interactive, streaming apps on top of your workflows. This guide will walk you through how to stream data from your workflow and how to consume it in your React app.

## Streaming data from workflows

There are multiple ways to stream data from your workflows. You can steam outputs, objects, events, or an arbitrary data.

TODO: improve this section

### Streaming an output

TODO

### Streaming objects

GenSX provides a `publishObject` function that allows you to stream an object to the client. It's designed for you to continually publish the latest state of an object as it gets updated. The changes will be patched to efficiently update the state on the client.

```typescript
import * as gensx from "@gensx/core";

interface Message {
  role: "user" | "assistant" | "system";
  content: string;
}

gensx.publishObject<Message[]>("messages", [
  { role: "assistant", content: "Hello, how can I help you today?" },
]);
```

You can also use `createObjectStream` to create a reusable function for publishing a given object.

```typescript
const publishMessages = gensx.createObjectStream<Message[]>("messages");

publishMessages([
  { role: "assistant", content: "Hello, how can I help you today?" },
]);
```

On the client side, you use the `useObject` hook to subscribe to the object and get the latest state.

### Streaming events

GenSX provides a `publishEvent` function that allows you to stream events to the client. It's designed for you to publish events that happen over time.

```typescript
interface ProgressEvent {
  progress: "brainstorming" | "researching" | "writing" | "editing";
}

gensx.publishEvent<ProgressEvent>("progress", {
  progress: "brainstorming",
});
```

There is also a `createEventStream` helper available for creating a reusable function for publishing the events.

On the client side, you use the `useEvents` hook to subscribe to the events and get a list of events or process them in the `onEvent` callback.

### Streaming arbitrary data

GenSX also provides a lower-level `publishData` function that allows you to pass arbitrary data to the client. It's designed for you to pass data that doesn't fit into the other categories.

```typescript
interface Answer {
  answer: string;
  confidence: number;
}

gensx.publishData<Answer>({
  answer: "42",
  confidence: 0.95,
});
```

Unlike `publishEvent` and `publishObject`, `publishData` does not take in a label and does not have a corresponding react hook so it will need to be consumed manually. The event will have `type: "data"` and the data will be available under the `data` property.

```json
{
  "type": "data",
  "data": {
    "answer": "42",
    "confidence": 0.95
  },
  "id": "1752110129329",
  "timestamp": "2025-07-10T01:15:29.329Z"
}
```

## Consuming streaming data in React

The `@gensx/react` library is the best way to consume streaming data from GenSX workflows.

### Setting up the passthrough API

To avoid exposing your GenSX API key to the client, we recommend setting up a passthrough API that forwards the request to the GenSX API. For brevity, we won't include the code here but you can grab [the code here](https://github.com/gensx-inc/gensx/blob/main/examples/chat-ux/app/api/gensx/%5Bworkflow%5D/route.ts) as a reference.

### Using the `useWorkflow` hook

The `useWorkflow` hook lets you run a workflow and subscribe to its events and output.

```typescript
const { inProgress, error, output, execution, run, stop } = useWorkflow<
  ChatInput, // the input type of the workflow
  ChatOutput // the output type of the workflow
>({
  config: {
    baseUrl: "/api/gensx/chat", // the passthrough API route
  },
});

// Run the workflow
await run({
  inputs: {
    userMessage: "Hello, how are you?",
  },
});
```

`useWorkflow` also supports callbacks for `onStart`, `onComplete`, `onError`, and `onEvent` that you can use to handle the workflow's lifecycle.

```typescript
const { error, output, execution, run } = useWorkflow<ChatInput, ChatOutput>({
  config: {
    baseUrl: "/api/gensx/chat", // the passthrough API route
  },
  onStart: () => {
    console.log("Workflow started");
  },
  onComplete: () => {
    console.log("Workflow completed");
  },
  onError: (error) => {
    console.error(error);
  },
  onEvent: (event) => {
    if (event.type === "data") {
      console.log(event.data);
    } else if (event.type === "event") {
      console.log(event.label);
      console.log(event.data);
    }
  },
});
```

### Using the `useObject` hook

The `useObject` hook lets you subscribe to an object published via `publishObject` and get it's latest state.

```typescript
const messages = useObject<Message[]>(execution, "messages");
```

Whenever a new version of the object is published, the value will automatically be updated making it a great way to render data in real-time. In this example, you can render the messages as they are published and the latest text will be streamed into the UI.

```tsx
messages.forEach((message) => {
  <ChatMessage role={message.role} content={message.content} />;
});
```

### Using the `useEvents` hook

The `useEvents` hook lets you subscribe to events and get the latest state.

```typescript
const progressEvents = useEvents<ProgressEvent>(execution, "progress");

progressEvents.forEach((event) => {
  console.log(event.progress);
});
```

## Additional events

In addition to the events created by `publishEvent`, `publishObject`, and `publishData`, GenSX also emits the following events:

| Event Type        | Description                        |
| ----------------- | ---------------------------------- |
| `start`           | Emitted when the workflow starts   |
| `end`             | Emitted when the workflow ends     |
| `component-start` | Emitted when a component starts    |
| `component-end`   | Emitted when a component ends      |
| `output`          | Emitted when an output is returned |
| `error`           | Emitted when an error occurs       |

### Example events:

```json
// start event
{
  "type": "start",
  "workflowName": "Chat",
  "id": "1752108242902",
  "timestamp": "2025-07-10T00:44:02.902Z"
}

// end event
{
  "type": "end",
  "id": "1752108243493",
  "timestamp": "2025-07-10T00:44:03.493Z"
}

// component-start event
{
  "type": "component-start",
  "componentName": "StreamText",
  "componentId": "StreamText:7e1339d69eee8d3d",
  "id": "1752108242902",
  "timestamp": "2025-07-10T00:44:02.902Z"
}

// component-end event
{
  "type": "component-end",
  "componentName": "StreamText",
  "componentId": "StreamText:7e1339d69eee8d3d",
  "id": "1752108242904",
  "timestamp": "2025-07-10T00:44:02.904Z"
}

// output event
{
    "id": "1752109017087",
    "timestamp": "2025-07-10T00:56:57.087Z",
    "type": "output",
    // content is a string, JSON will be stringified
    "content": "{\"message\":\"Hello, world!\"}"
}

// error event
{
    "id": "1752109017087",
    "timestamp": "2025-07-10T00:56:57.087Z",
    "type": "error",
    "error": "An error occurred"
}
```

## Consuming streaming data from the API

To consume the streaming messages from the API, you need to set the `Accept` header to `text/event-stream` or `application/x-ndjson`. The `@gensx/react` and `@gensx/client` libraries automatically set the `Accept` header for you.

TODO: finish this section

## Examples

TODO: Add example links
